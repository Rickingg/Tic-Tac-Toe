<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo da Velha Infinito</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Fundo animado com padrões geométricos */
        .background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(45deg, #1a1a2e, #16213e, #0f3460);
            animation: gradientShift 8s ease-in-out infinite;
        }

        @keyframes gradientShift {
            0%, 100% { 
                background: linear-gradient(45deg, #1a1a2e, #16213e, #0f3460);
            }
            50% { 
                background: linear-gradient(45deg, #0f3460, #16213e, #1a1a2e);
            }
        }

        .background::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 50%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 20%, rgba(0, 188, 212, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(0, 188, 212, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, rgba(0, 188, 212, 0.05) 0%, transparent 50%);
            background-size: 100px 100px, 150px 150px, 200px 200px;
            animation: floatLeft 12s ease-in-out infinite;
        }

        .background::after {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            width: 50%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 20%, rgba(233, 30, 99, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(233, 30, 99, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, rgba(233, 30, 99, 0.05) 0%, transparent 50%);
            background-size: 120px 120px, 180px 180px, 250px 250px;
            animation: floatRight 15s ease-in-out infinite;
        }

        @keyframes floatLeft {
            0%, 100% { 
                transform: translateY(0px) rotate(0deg);
                background-position: 0% 0%, 50% 50%, 0% 100%;
            }
            50% { 
                transform: translateY(-20px) rotate(2deg);
                background-position: 20% 20%, 70% 30%, 10% 80%;
            }
        }

        @keyframes floatRight {
            0%, 100% { 
                transform: translateY(0px) rotate(0deg);
                background-position: 0% 0%, 50% 50%, 100% 0%;
            }
            50% { 
                transform: translateY(20px) rotate(-2deg);
                background-position: 30% 10%, 80% 70%, 90% 20%;
            }
        }

        /* Destacar lado do jogador ativo */
        .background.x-turn::before {
            background: 
                radial-gradient(circle at 20% 20%, rgba(0, 188, 212, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(0, 188, 212, 0.15) 0%, transparent 50%),
                linear-gradient(135deg, rgba(0, 188, 212, 0.1) 0%, transparent 50%);
            filter: brightness(1.3);
        }

        .background.x-turn::after {
            opacity: 0.6;
        }

        .background.o-turn::before {
            opacity: 0.6;
        }

        .background.o-turn::after {
            background: 
                radial-gradient(circle at 20% 20%, rgba(233, 30, 99, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(233, 30, 99, 0.15) 0%, transparent 50%),
                linear-gradient(135deg, rgba(233, 30, 99, 0.1) 0%, transparent 50%);
            filter: brightness(1.3);
        }

        /* Destacar lado vencedor */
        .background.x-winning::before {
            filter: brightness(1.5) drop-shadow(0 0 30px rgba(0, 188, 212, 0.3));
        }

        .background.o-winning::after {
            filter: brightness(1.5) drop-shadow(0 0 30px rgba(233, 30, 99, 0.3));
        }

        /* Barra superior com controles */
        .top-bar {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(15px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        /* Placar central */
        .scoreboard {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .player-score {
            padding: 10px 18px;
            border-radius: 15px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
        }

        .player-x {
            background: linear-gradient(135deg, rgba(0, 188, 212, 0.2), rgba(0, 188, 212, 0.1));
            border-color: rgba(0, 188, 212, 0.4);
            box-shadow: 0 4px 15px rgba(0, 188, 212, 0.2);
        }

        .player-o {
            background: linear-gradient(135deg, rgba(233, 30, 99, 0.2), rgba(233, 30, 99, 0.1));
            border-color: rgba(233, 30, 99, 0.4);
            box-shadow: 0 4px 15px rgba(233, 30, 99, 0.2);
        }

        .player-score.winning {
            transform: scale(1.15);
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.4);
            animation: winningPulse 2s ease-in-out infinite;
        }

        @keyframes winningPulse {
            0%, 100% { transform: scale(1.15); }
            50% { transform: scale(1.2); }
        }

        /* Botões de controle */
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 18px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .btn:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25), rgba(255, 255, 255, 0.15));
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .mode-indicator {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 0.1));
            border-color: rgba(76, 175, 80, 0.4);
        }

        .bot-mode {
            background: linear-gradient(135deg, rgba(255, 152, 0, 0.2), rgba(255, 152, 0, 0.1));
            border-color: rgba(255, 152, 0, 0.4);
        }

        .difficulty-easy {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 0.1));
            border-color: rgba(76, 175, 80, 0.4);
        }

        .difficulty-medium {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.2), rgba(255, 193, 7, 0.1));
            border-color: rgba(255, 193, 7, 0.4);
        }

        .difficulty-hard {
            background: linear-gradient(135deg, rgba(255, 87, 34, 0.2), rgba(255, 87, 34, 0.1));
            border-color: rgba(255, 87, 34, 0.4);
        }

        .difficulty-impossible {
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.2), rgba(244, 67, 54, 0.1));
            border-color: rgba(244, 67, 54, 0.4);
        }

        /* Container principal do jogo */
        .game-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
        }

        /* Tabuleiro do jogo - MAIS DESTACADO */
        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 12px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.2));
            padding: 25px;
            border-radius: 25px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .board::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                rgba(0, 188, 212, 0.3) 0%,
                rgba(233, 30, 99, 0.3) 25%,
                rgba(76, 175, 80, 0.3) 50%,
                rgba(255, 193, 7, 0.3) 75%,
                rgba(0, 188, 212, 0.3) 100%);
            border-radius: 27px;
            z-index: -1;
            animation: borderGlow 4s linear infinite;
        }

        @keyframes borderGlow {
            0% { 
                background: linear-gradient(45deg, 
                    rgba(0, 188, 212, 0.3) 0%,
                    rgba(233, 30, 99, 0.3) 25%,
                    rgba(76, 175, 80, 0.3) 50%,
                    rgba(255, 193, 7, 0.3) 75%,
                    rgba(0, 188, 212, 0.3) 100%);
            }
            25% { 
                background: linear-gradient(45deg, 
                    rgba(233, 30, 99, 0.3) 0%,
                    rgba(76, 175, 80, 0.3) 25%,
                    rgba(255, 193, 7, 0.3) 50%,
                    rgba(0, 188, 212, 0.3) 75%,
                    rgba(233, 30, 99, 0.3) 100%);
            }
            50% { 
                background: linear-gradient(45deg, 
                    rgba(76, 175, 80, 0.3) 0%,
                    rgba(255, 193, 7, 0.3) 25%,
                    rgba(0, 188, 212, 0.3) 50%,
                    rgba(233, 30, 99, 0.3) 75%,
                    rgba(76, 175, 80, 0.3) 100%);
            }
            75% { 
                background: linear-gradient(45deg, 
                    rgba(255, 193, 7, 0.3) 0%,
                    rgba(0, 188, 212, 0.3) 25%,
                    rgba(233, 30, 99, 0.3) 50%,
                    rgba(76, 175, 80, 0.3) 75%,
                    rgba(255, 193, 7, 0.3) 100%);
            }
            100% { 
                background: linear-gradient(45deg, 
                    rgba(0, 188, 212, 0.3) 0%,
                    rgba(233, 30, 99, 0.3) 25%,
                    rgba(76, 175, 80, 0.3) 50%,
                    rgba(255, 193, 7, 0.3) 75%,
                    rgba(0, 188, 212, 0.3) 100%);
            }
        }

        .cell {
            width: 110px;
            height: 110px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 52px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        .cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .cell:hover:not(.filled)::before {
            left: 100%;
        }

        .cell:hover:not(.filled) {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .cell.filled {
            cursor: not-allowed;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
        }

        .cell.x {
            color: #00bcd4;
            text-shadow: 
                0 0 10px rgba(0, 188, 212, 0.6),
                0 0 20px rgba(0, 188, 212, 0.4),
                0 0 30px rgba(0, 188, 212, 0.2);
            animation: symbolGlow 2s ease-in-out infinite alternate;
        }

        .cell.o {
            color: #e91e63;
            text-shadow: 
                0 0 10px rgba(233, 30, 99, 0.6),
                0 0 20px rgba(233, 30, 99, 0.4),
                0 0 30px rgba(233, 30, 99, 0.2);
            animation: symbolGlow 2s ease-in-out infinite alternate;
        }

        @keyframes symbolGlow {
            0% { 
                filter: brightness(1);
                transform: scale(1);
            }
            100% { 
                filter: brightness(1.2);
                transform: scale(1.02);
            }
        }

        /* Símbolo em modo de desaparecimento */
        .cell.fading {
            opacity: 0.5;
            animation: pulse 1s infinite;
            background: linear-gradient(135deg, rgba(255, 255, 0, 0.1), rgba(255, 255, 0, 0.05));
            border-color: rgba(255, 255, 0, 0.3);
        }

        @keyframes pulse {
            0%, 100% { 
                opacity: 0.5;
                transform: scale(1);
            }
            50% { 
                opacity: 0.3;
                transform: scale(0.95);
            }
        }

        /* Linha vencedora */
        .cell.winning {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.2));
            animation: winningGlow 0.8s ease-in-out infinite alternate;
            border-color: rgba(255, 255, 255, 0.6);
        }

        @keyframes winningGlow {
            0% { 
                box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
                transform: scale(1);
            }
            100% { 
                box-shadow: 0 0 25px rgba(255, 255, 255, 0.8);
                transform: scale(1.05);
            }
        }

        /* Indicador de turno */
        .turn-indicator {
            position: absolute;
            top: 60%;
            transform: translateY(-50%);
            font-size: 18px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            transition: all 0.3s ease;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.2));
            padding: 12px 18px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .turn-indicator.left {
            left: 20px;
        }

        .turn-indicator.right {
            right: 20px;
        }

        .turn-indicator.active {
            transform: translateY(-50%) scale(1.2);
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
        }

        /* Animação de vitória */
        .victory-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0.9) 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            backdrop-filter: blur(10px);
        }

        .victory-overlay.show {
            opacity: 1;
            pointer-events: all;
        }

        .victory-message {
            text-align: center;
            color: white;
            font-size: 56px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            animation: victoryPulse 1s ease-in-out infinite alternate;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            padding: 30px 50px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .victory-message.x-wins {
            color: #00bcd4;
            text-shadow: 0 0 30px rgba(0, 188, 212, 0.8);
            border-color: rgba(0, 188, 212, 0.5);
        }

        .victory-message.o-wins {
            color: #e91e63;
            text-shadow: 0 0 30px rgba(233, 30, 99, 0.8);
            border-color: rgba(233, 30, 99, 0.5);
        }

        @keyframes victoryPulse {
            0% { 
                transform: scale(1);
                filter: brightness(1);
            }
            100% { 
                transform: scale(1.05);
                filter: brightness(1.3);
            }
        }

        .victory-confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ffeb3b;
            animation: confetti 3s ease-out forwards;
        }

        @keyframes confetti {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Responsividade */
        @media (max-width: 768px) {
            .top-bar {
                flex-direction: column;
                text-align: center;
            }

            .scoreboard {
                font-size: 20px;
                gap: 10px;
            }

            .cell {
                width: 85px;
                height: 85px;
                font-size: 40px;
            }

            .turn-indicator {
                position: static;
                margin: 10px 0;
                transform: none;
            }

            .turn-indicator.active {
                transform: scale(1.1);
                box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
            }

            .victory-message {
                font-size: 40px;
                padding: 20px 30px;
            }
        }

        @media (max-width: 480px) {
            .cell {
                width: 70px;
                height: 70px;
                font-size: 32px;
            }

            .scoreboard {
                font-size: 18px;
            }

            .btn {
                padding: 10px 15px;
                font-size: 12px;
            }

            .victory-message {
                font-size: 32px;
                padding: 15px 25px;
            }
        }
    </style>
</head>
<body>
    <div class="background" id="background"></div>
    
    <!-- Barra superior com controles -->
    <div class="top-bar">
        <div class="controls">
            <button class="btn" onclick="resetRound()">🔁 Reiniciar Rodada</button>
            <button class="btn" onclick="resetScore()">🔄 Reiniciar Placar</button>
            <button class="btn mode-indicator" onclick="toggleMode()" id="modeBtn">🔃 Modo: Infinito</button>
            <button class="btn" onclick="toggleBotMode()" id="botBtn">🤖 Vs Humano</button>
            <button class="btn" onclick="changeDifficulty()" id="difficultyBtn" style="display: none;">⚡ Fácil</button>
        </div>
        
        <!-- Placar central -->
        <div class="scoreboard">
            <div class="player-score player-x" id="scoreX">
                <span id="playerXLabel">X</span> <span id="xScore">0</span>
            </div>
            <div style="color: white;">x</div>
            <div class="player-score player-o" id="scoreO">
                <span id="oScore">0</span> <span id="playerOLabel">O</span>
            </div>
        </div>
        
        <!-- Indicadores de turno para mobile -->
        <div class="turn-indicator" id="turnIndicator">Vez do X</div>
    </div>

    <!-- Indicadores de turno para desktop -->
    <div class="turn-indicator left" id="turnLeft">Sua vez!</div>
    <div class="turn-indicator right" id="turnRight">Aguarde...</div>

    <!-- Overlay de vitória -->
    <div class="victory-overlay" id="victoryOverlay">
        <div class="victory-message" id="victoryMessage">
            X Venceu!
        </div>
    </div>

    <!-- Container do jogo -->
    <div class="game-container">
        <div class="board" id="board">
            <!-- Células serão criadas dinamicamente -->
        </div>
    </div>

    <script>
        // Estado do jogo
        let currentPlayer = 'X';
        let gameMode = 'infinite'; // 'infinite', 'classic', 'vsbot'
        let botDifficulty = 'medium'; // 'easy', 'medium', 'hard', 'impossible'
        let isVsBot = false;
        let board = Array(9).fill('');
        let gameActive = true;
        let scores = { X: 0, O: 0 };
        
        // Para o modo infinito: histórico de jogadas (ordem cronológica)
        let moveHistory = []; // Array de objetos: {player, position, moveNumber}
        let moveCounter = 0;
        let fadingCell = null; // Célula que está prestes a desaparecer

        // Combinações vencedoras
        const winningCombinations = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Linhas
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Colunas
            [0, 4, 8], [2, 4, 6] // Diagonais
        ];

        // Inicializar o jogo
        function initGame() {
            createBoard();
            updateDisplay();
        }

        // Criar o tabuleiro
        function createBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.onclick = () => makeMove(i);
                boardElement.appendChild(cell);
            }
        }

        // Fazer uma jogada
        function makeMove(position) {
            if (!gameActive || board[position] !== '') {
                return;
            }

            // MODO INFINITO: Processar desaparecimento antes da nova jogada
            if (gameMode === 'infinite' && fadingCell !== null && moveHistory.length >= 6) {
                // A partir do 7º lance, remove o símbolo que estava em modo de desaparecimento
                board[fadingCell] = '';
                // Remove da lista de histórico
                moveHistory = moveHistory.filter(move => move.position !== fadingCell);
                fadingCell = null;
            }

            // Fazer a jogada atual
            board[position] = currentPlayer;
            moveCounter++;

            // Adicionar ao histórico (modo infinito)
            if (gameMode === 'infinite') {
                moveHistory.push({
                    player: currentPlayer,
                    position: position,
                    moveNumber: moveCounter
                });
            }

            // Verificar vitória
            if (checkWinner()) {
                gameActive = false;
                scores[currentPlayer]++;
                showVictoryAnimation(currentPlayer);
                setTimeout(() => {
                    resetRound();
                }, 3000);
                updateDisplay();
                return;
            }

            // Verificar empate (apenas no modo clássico ou quando não é modo infinito)
            if (gameMode !== 'infinite' && !board.includes('')) {
                gameActive = false;
                setTimeout(() => {
                    showVictoryAnimation('empate');
                    setTimeout(() => {
                        resetRound();
                    }, 3000);
                }, 500);
                return;
            }

            // MODO INFINITO: Marcar próximo símbolo para desaparecer
            if (gameMode === 'infinite' && moveHistory.length >= 6) {
                // A partir do 6º lance, o símbolo mais antigo entra em modo de desaparecimento
                const oldestMove = moveHistory[0];
                fadingCell = oldestMove.position;
            }

            // Alternar jogador
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            updateDisplay();

            // Se é modo vs bot e agora é a vez do bot (O), fazer jogada do bot
            if (isVsBot && currentPlayer === 'O' && gameActive) {
                setTimeout(() => {
                    makeBotMove();
                }, 500 + Math.random() * 1000); // Delay aleatório para parecer mais humano
            }
        }

        // Verificar vencedor
        function checkWinner() {
            for (let combination of winningCombinations) {
                const [a, b, c] = combination;
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    // Destacar células vencedoras
                    const cells = document.querySelectorAll('.cell');
                    combination.forEach(index => {
                        cells[index].classList.add('winning');
                    });
                    return true;
                }
            }
            return false;
        }

        // Atualizar display
        function updateDisplay() {
            const cells = document.querySelectorAll('.cell');
            const background = document.getElementById('background');
            
            // Atualizar células do tabuleiro
            cells.forEach((cell, index) => {
                cell.textContent = board[index];
                cell.className = 'cell';
                
                if (board[index] !== '') {
                    cell.classList.add('filled', board[index].toLowerCase());
                }
                
                // Marcar célula em modo de desaparecimento
                if (gameMode === 'infinite' && fadingCell === index) {
                    cell.classList.add('fading');
                }
            });

            // Atualizar placar
            document.getElementById('xScore').textContent = scores.X;
            document.getElementById('oScore').textContent = scores.O;
            
            // Destacar lado do jogador atual e lado vencedor no fundo
            background.className = 'background';
            const scoreX = document.getElementById('scoreX');
            const scoreO = document.getElementById('scoreO');
            
            scoreX.classList.remove('winning');
            scoreO.classList.remove('winning');
            
            // Destacar lado do jogador atual
            if (gameActive) {
                if (currentPlayer === 'X') {
                    background.classList.add('x-turn');
                } else {
                    background.classList.add('o-turn');
                }
            }
            
            // Destacar lado vencedor no placar (sobrescreve o destaque de turno)
            if (scores.X > scores.O) {
                background.classList.remove('x-turn', 'o-turn');
                background.classList.add('x-winning');
                scoreX.classList.add('winning');
            } else if (scores.O > scores.X) {
                background.classList.remove('x-turn', 'o-turn');
                background.classList.add('o-winning');
                scoreO.classList.add('winning');
            }

            // Atualizar indicadores de turno
            updateTurnIndicators();
        }

        // Atualizar indicadores de turno
        function updateTurnIndicators() {
            const turnLeft = document.getElementById('turnLeft');
            const turnRight = document.getElementById('turnRight');
            const turnIndicator = document.getElementById('turnIndicator');
            
            if (currentPlayer === 'X') {
                turnLeft.classList.add('active');
                turnRight.classList.remove('active');
                if (isVsBot) {
                    turnLeft.textContent = 'Sua vez!';
                    turnRight.textContent = 'Bot aguarda...';
                    turnIndicator.textContent = 'Sua vez (X)';
                } else {
                    turnLeft.textContent = 'Sua vez!';
                    turnRight.textContent = 'Aguarde...';
                    turnIndicator.textContent = 'Vez do X';
                }
            } else {
                turnLeft.classList.remove('active');
                turnRight.classList.add('active');
                if (isVsBot) {
                    turnLeft.textContent = 'Aguarde...';
                    turnRight.textContent = 'Bot pensando...';
                    turnIndicator.textContent = 'Bot pensando (O)';
                } else {
                    turnLeft.textContent = 'Aguarde...';
                    turnRight.textContent = 'Sua vez!';
                    turnIndicator.textContent = 'Vez do O';
                }
            }
        }

        // Mostrar animação de vitória
        function showVictoryAnimation(winner) {
            const overlay = document.getElementById('victoryOverlay');
            const message = document.getElementById('victoryMessage');
            
            if (winner === 'empate') {
                message.textContent = 'Empate!';
                message.className = 'victory-message';
            } else {
                message.textContent = `${winner} Venceu!`;
                message.className = `victory-message ${winner.toLowerCase()}-wins`;
            }
            
            overlay.classList.add('show');
            
            // Criar confetes
            createConfetti(winner);
            
            // Esconder overlay após 3 segundos
            setTimeout(() => {
                overlay.classList.remove('show');
            }, 2500);
        }

        // Criar efeito de confetes
        function createConfetti(winner) {
            const colors = winner === 'X' ? ['#00bcd4', '#4dd0e1', '#80deea'] : 
                          winner === 'O' ? ['#e91e63', '#f06292', '#f8bbd9'] : 
                          ['#ffeb3b', '#fff176', '#ffff8d'];
            
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'victory-confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = Math.random() * 2 + 's';
                    document.body.appendChild(confetti);
                    
                    setTimeout(() => {
                        confetti.remove();
                    }, 3000);
                }, i * 50);
            }
        }

        // Reiniciar rodada
        function resetRound() {
            board = Array(9).fill('');
            currentPlayer = 'X';
            gameActive = true;
            moveHistory = [];
            moveCounter = 0;
            fadingCell = null;
            
            // Limpar destaque das células
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.classList.remove('winning', 'fading');
            });
            
            updateDisplay();
        }

        // Reiniciar placar
        function resetScore() {
            scores = { X: 0, O: 0 };
            resetRound();
        }

        // Alternar modo de jogo
        function toggleMode() {
            if (gameMode === 'infinite') {
                gameMode = 'classic';
            } else {
                gameMode = 'infinite';
            }
            const modeBtn = document.getElementById('modeBtn');
            modeBtn.textContent = `🔃 Modo: ${gameMode === 'infinite' ? 'Infinito' : 'Clássico'}`;
            resetRound();
        }

        // Alternar modo bot
        function toggleBotMode() {
            isVsBot = !isVsBot;
            const botBtn = document.getElementById('botBtn');
            const difficultyBtn = document.getElementById('difficultyBtn');
            const playerOLabel = document.getElementById('playerOLabel');
            
            if (isVsBot) {
                botBtn.textContent = '🤖 Vs Bot';
                botBtn.classList.add('bot-mode');
                difficultyBtn.style.display = 'inline-block';
                playerOLabel.textContent = '🤖';
            } else {
                botBtn.textContent = '🤖 Vs Humano';
                botBtn.classList.remove('bot-mode');
                difficultyBtn.style.display = 'none';
                playerOLabel.textContent = 'O';
            }
            resetRound();
        }

        // Alterar dificuldade do bot
        function changeDifficulty() {
            const difficulties = ['easy', 'medium', 'hard', 'impossible'];
            const labels = ['Fácil', 'Médio', 'Difícil', 'Impossível'];
            const currentIndex = difficulties.indexOf(botDifficulty);
            const nextIndex = (currentIndex + 1) % difficulties.length;
            
            botDifficulty = difficulties[nextIndex];
            
            const difficultyBtn = document.getElementById('difficultyBtn');
            difficultyBtn.textContent = `⚡ ${labels[nextIndex]}`;
            
            // Remover classes anteriores e adicionar nova
            difficultyBtn.className = 'btn';
            difficultyBtn.classList.add(`difficulty-${botDifficulty}`);
            
            resetRound();
        }

        // IA do Bot
        function makeBotMove() {
            if (!gameActive || currentPlayer !== 'O') return;

            let move;
            
            switch (botDifficulty) {
                case 'easy':
                    move = getRandomMove();
                    break;
                case 'medium':
                    move = getMediumMove();
                    break;
                case 'hard':
                    move = getHardMove();
                    break;
                case 'impossible':
                    move = getImpossibleMove();
                    break;
                default:
                    move = getRandomMove();
            }

            if (move !== -1) {
                makeMove(move);
            }
        }

        // Movimento aleatório (Fácil)
        function getRandomMove() {
            const availableMoves = board.map((cell, index) => cell === '' ? index : null).filter(val => val !== null);
            return availableMoves.length > 0 ? availableMoves[Math.floor(Math.random() * availableMoves.length)] : -1;
        }

        // Movimento médio - 70% estratégico, 30% aleatório
        function getMediumMove() {
            if (Math.random() < 0.3) {
                return getRandomMove();
            }
            return getStrategicMove();
        }

        // Movimento difícil - sempre estratégico com algumas falhas ocasionais
        function getHardMove() {
            if (Math.random() < 0.1) {
                return getRandomMove();
            }
            return getStrategicMove();
        }

        // Movimento impossível - minimax perfeito
        function getImpossibleMove() {
            return getBestMove();
        }

        // Movimento estratégico básico
        function getStrategicMove() {
            // 1. Verificar se pode vencer
            for (let combination of winningCombinations) {
                const [a, b, c] = combination;
                if (board[a] === 'O' && board[b] === 'O' && board[c] === '') return c;
                if (board[a] === 'O' && board[c] === 'O' && board[b] === '') return b;
                if (board[b] === 'O' && board[c] === 'O' && board[a] === '') return a;
            }

            // 2. Verificar se precisa bloquear o jogador
            for (let combination of winningCombinations) {
                const [a, b, c] = combination;
                if (board[a] === 'X' && board[b] === 'X' && board[c] === '') return c;
                if (board[a] === 'X' && board[c] === 'X' && board[b] === '') return b;
                if (board[b] === 'X' && board[c] === 'X' && board[a] === '') return a;
            }

            // 3. Tentar pegar o centro
            if (board[4] === '') return 4;

            // 4. Tentar pegar os cantos
            const corners = [0, 2, 6, 8];
            const availableCorners = corners.filter(corner => board[corner] === '');
            if (availableCorners.length > 0) {
                return availableCorners[Math.floor(Math.random() * availableCorners.length)];
            }

            // 5. Pegar qualquer posição disponível
            return getRandomMove();
        }

        // Algoritmo Minimax para movimento impossível
        function getBestMove() {
            let bestScore = -Infinity;
            let bestMove = -1;

            for (let i = 0; i < 9; i++) {
                if (board[i] === '') {
                    board[i] = 'O';
                    let score = minimax(board, 0, false);
                    board[i] = '';
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = i;
                    }
                }
            }
            
            return bestMove !== -1 ? bestMove : getRandomMove();
        }

        // Algoritmo Minimax
        function minimax(board, depth, isMaximizing) {
            // Verificar estado terminal
            const winner = checkWinnerForMinimax();
            if (winner === 'O') return 10 - depth;
            if (winner === 'X') return depth - 10;
            if (!board.includes('')) return 0;

            if (isMaximizing) {
                let bestScore = -Infinity;
                for (let i = 0; i < 9; i++) {
                    if (board[i] === '') {
                        board[i] = 'O';
                        let score = minimax(board, depth + 1, false);
                        board[i] = '';
                        bestScore = Math.max(score, bestScore);
                    }
                }
                return bestScore;
            } else {
                let bestScore = Infinity;
                for (let i = 0; i < 9; i++) {
                    if (board[i] === '') {
                        board[i] = 'X';
                        let score = minimax(board, depth + 1, true);
                        board[i] = '';
                        bestScore = Math.min(score, bestScore);
                    }
                }
                return bestScore;
            }
        }

        // Verificar vencedor para minimax (sem efeitos visuais)
        function checkWinnerForMinimax() {
            for (let combination of winningCombinations) {
                const [a, b, c] = combination;
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return board[a];
                }
            }
            return null;
        }

        // Inicializar quando a página carregar
        window.onload = initGame;
    </script>
</body>
</html>
